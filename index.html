<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>16-bit Coffee Wheels</title>
  <style>
    :root{
      --bg:#020202;
      --fg:#F7F7F7;

      --panel1:#070707;
      --panel2:#0D0D0D;

      --line:#F7F7F7;
      --lineDim:rgba(247,247,247,.28);

      --red:#3A0000;      /* dark red box fill */
      --red2:#5A0000;     /* red inner border glow */
      --shadow:#000;

      --itemH:56px;
      --visible:5;        /* odd */
      --padX:14px;
      --inset:10px;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      -webkit-tap-highlight-color: transparent;
      image-rendering: pixelated;
      overflow:hidden;
    }

    /* CRT scanlines + flicker + vignette */
    .crt::before{
      content:"";
      position:fixed;
      inset:-20%;
      pointer-events:none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.05) 0px,
          rgba(255,255,255,0.05) 1px,
          rgba(0,0,0,0.00) 3px,
          rgba(0,0,0,0.00) 6px
        );
      opacity:.22;
      mix-blend-mode: overlay;
      animation: scan 2.8s linear infinite;
    }
    .crt::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(ellipse at center, rgba(0,0,0,0) 45%, rgba(0,0,0,.35) 100%);
      animation: flicker 3.5s infinite steps(1,end);
      opacity:.9;
    }
    @keyframes scan{
      0%{ transform: translateY(0px); }
      100%{ transform: translateY(18px); }
    }
    @keyframes flicker{
      0%, 100%{ filter: brightness(1); }
      10%{ filter: brightness(.98); }
      20%{ filter: brightness(1.02); }
      30%{ filter: brightness(.99); }
      40%{ filter: brightness(1.01); }
      50%{ filter: brightness(1.00); }
      60%{ filter: brightness(.985); }
      70%{ filter: brightness(1.02); }
      80%{ filter: brightness(.99); }
      90%{ filter: brightness(1.01); }
    }

    .wrap{ width:min(860px, 100%); }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }

    /* Pixel panel with notches */
    .panel{
      position:relative;
      padding: 14px;
      background: linear-gradient(180deg, var(--panel2), var(--panel1));
      box-shadow:
        0 0 0 2px var(--line),
        0 0 0 6px rgba(255,255,255,.08),
        0 16px 34px rgba(0,0,0,.65);
    }
    .panel:before, .panel:after{
      content:"";
      position:absolute;
      width:10px; height:10px;
      background: var(--bg);
      box-shadow: 0 0 0 2px var(--line);
    }
    .panel:before{ top:-2px; left:-2px; }
    .panel:after{ bottom:-2px; right:-2px; }

    .title{
      text-align:center;
      font-weight: 900;
      font-size: 14px;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin: 2px 0 12px;
      text-shadow: 0 2px 0 rgba(0,0,0,.8);
    }

    .wheelWrap{
      position:relative;
      height: calc(var(--itemH) * var(--visible));
      overflow:hidden;
      background: #050505;
      touch-action: none;
      user-select:none;

      box-shadow:
        inset 0 0 0 2px var(--line),
        inset 0 0 0 6px rgba(255,255,255,.07);
    }

    /* red selection box overlay */
    .selectBox{
      position:absolute;
      left: var(--inset);
      right: var(--inset);
      top: calc((var(--visible) / 2) * var(--itemH) - (var(--itemH) / 2));
      height: var(--itemH);
      z-index: 5;
      display:flex;
      align-items:center;
      justify-content:center;

      background: linear-gradient(180deg, #2A0000, var(--red));
      box-shadow:
        inset 0 0 0 2px var(--line),
        inset 0 0 0 6px rgba(0,0,0,.55),
        0 0 0 2px rgba(0,0,0,.35),
        0 0 18px rgba(255,0,0,.18);
    }

    .selectedText{
      font-size: 40px;
      font-weight: 900;
      letter-spacing: 1px;
      color: var(--fg);
      text-shadow:
        0 3px 0 rgba(0,0,0,.85),
        0 0 10px rgba(255,255,255,.10);
      /* subtle 16-bit shimmer */
      animation: shimmer 1.6s steps(2,end) infinite;
    }
    @keyframes shimmer{
      0%, 100%{ filter: brightness(1); transform: translateY(0px); }
      50%{ filter: brightness(1.08); transform: translateY(-1px); }
    }

    /* fade top/bottom */
    .wheelWrap .fade{
      position:absolute;
      inset:0;
      z-index:4;
      pointer-events:none;
      background: linear-gradient(to bottom,
        rgba(2,2,2,0.98) 0%,
        rgba(2,2,2,0.00) 28%,
        rgba(2,2,2,0.00) 72%,
        rgba(2,2,2,0.98) 100%);
    }

    .track{
      position:absolute;
      inset:0;
      z-index:1;
      will-change: transform;
      transform: translateY(0px);
    }

    .items{
      width:100%;
      padding-top: calc((var(--visible) / 2) * var(--itemH));
      padding-bottom: calc((var(--visible) / 2) * var(--itemH));
      padding-left: var(--padX);
      padding-right: var(--padX);
    }

    .item{
      height: var(--itemH);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 34px;
      font-weight: 900;
      letter-spacing: .5px;
      font-variant-numeric: tabular-nums;
      color: rgba(247,247,247,.55);
      text-shadow: 0 2px 0 rgba(0,0,0,.75);
    }

    .controls{
      display:flex;
      gap:10px;
      margin-top:12px;
    }
    .btn{
      flex:1;
      border:0;
      background: #060606;
      color: var(--fg);
      font-family: inherit;
      font-weight: 900;
      letter-spacing: 1px;
      padding: 12px 10px;
      font-size: 18px;
      box-shadow:
        0 0 0 2px var(--line),
        inset 0 0 0 2px rgba(0,0,0,.55),
        0 8px 0 rgba(0,0,0,.60);
    }
    .btn:active{
      transform: translateY(6px);
      box-shadow:
        0 0 0 2px var(--line),
        inset 0 0 0 2px rgba(0,0,0,.55),
        0 2px 0 rgba(0,0,0,.60);
    }

    @media (max-width: 520px){
      .grid{ grid-template-columns: 1fr; }
      .selectedText{ font-size: 42px; }
      .item{ font-size: 36px; }
    }
  </style>
</head>

<body class="crt">
  <div class="wrap">
    <div class="grid">
      <div class="panel">
        <div class="title">Coffee (g)</div>
        <div class="wheelWrap" id="coffeeWrap" aria-label="Coffee wheel">
          <div class="track" id="coffeeTrack">
            <div class="items" id="coffeeItems"></div>
          </div>

          <!-- Selected value ALWAYS inside the box -->
          <div class="selectBox"><div class="selectedText" id="coffeeSelected">16.0</div></div>
          <div class="fade"></div>
        </div>
        <div class="controls">
          <button class="btn" id="coffeeDown" type="button">▼</button>
          <button class="btn" id="coffeeUp" type="button">▲</button>
        </div>
      </div>

      <div class="panel">
        <div class="title">Water (ml)</div>
        <div class="wheelWrap" id="waterWrap" aria-label="Water wheel">
          <div class="track" id="waterTrack">
            <div class="items" id="waterItems"></div>
          </div>

          <div class="selectBox"><div class="selectedText" id="waterSelected">1000</div></div>
          <div class="fade"></div>
        </div>
        <div class="controls">
          <button class="btn" id="waterDown" type="button">▼</button>
          <button class="btn" id="waterUp" type="button">▲</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // LOCKED ratio: 16 / 250
  const R_C = 16, R_W = 250;

  const ITEM_H = 56;         // must match CSS --itemH
  const VISIBLE = 5;

  // Requested accuracy
  const waterCfg = { min:150, max:1000, step:5, start:1000 };
  const coffeeStep = 0.1;

  const clamp = (x,a,b)=> Math.min(b, Math.max(a,x));
  const roundTo = (x, step)=> Math.round(x/step)*step;
  const fmt1 = (x)=> (Math.round(x*10)/10).toFixed(1);

  function buildValues(min, max, step){
    const out = [];
    const n = Math.round((max - min) / step);
    for(let i=0;i<=n;i++) out.push(min + i*step);
    if (Math.abs(out[out.length-1] - max) > step/2) out.push(max);
    return out;
  }

  const waterValues = buildValues(waterCfg.min, waterCfg.max, waterCfg.step);

  // Derived coffee range from locked ratio
  const coffeeMin = roundTo((waterCfg.min * R_C) / R_W, coffeeStep);
  const coffeeMax = roundTo((waterCfg.max * R_C) / R_W, coffeeStep);
  const coffeeValues = buildValues(coffeeMin, coffeeMax, coffeeStep);

  const coffeeFromWater = (w)=> roundTo((w * R_C) / R_W, coffeeStep);
  const waterFromCoffee = (c)=> roundTo((c * R_W) / R_C, waterCfg.step);

  function renderItems(container, values, formatter){
    container.innerHTML = "";
    for(const v of values){
      const div = document.createElement("div");
      div.className = "item";
      div.textContent = formatter(v);
      container.appendChild(div);
    }
  }

  renderItems(document.getElementById("waterItems"),  waterValues,  v => String(Math.round(v)));
  renderItems(document.getElementById("coffeeItems"), coffeeValues, v => fmt1(v));

  const waterSelected  = document.getElementById("waterSelected");
  const coffeeSelected = document.getElementById("coffeeSelected");

  // Faster + smoother: higher follow gain + short snap time.
  class DragWheel {
    constructor({ wrap, track, values, onChange, setSelectedText }) {
      this.wrap = wrap;
      this.track = track;
      this.values = values;
      this.onChange = onChange;
      this.setSelectedText = setSelectedText;

      this.index = 0;

      // We place the selected row at the center box by offsetting by CENTER_PX:
      // translateY = CENTER_PX - index*ITEM_H (+ drag delta)
      this.CENTER_PX = Math.floor(VISIBLE / 2) * ITEM_H;

      this.offset = this.CENTER_PX; // current translateY
      this.target = this.CENTER_PX; // target translateY

      this.dragging = false;
      this.startY = 0;
      this.startTarget = 0;

      this.raf = null;
      this.snapRaf = null;

      this.apply();
      this.bind();
    }

    apply(){ this.track.style.transform = `translateY(${this.offset}px)`; }

    setIndex(idx, emit=true){
      const i = clamp(idx, 0, this.values.length - 1);
      this.index = i;
      this.target = this.CENTER_PX - (i * ITEM_H);
      this.offset = this.target;
      this.apply();
      const v = this.values[this.index];
      this.setSelectedText?.(v);
      if (emit) this.onChange?.(v, i);
    }

    startFollow(){
      if (this.raf) return;
      const tick = () => {
        // higher = faster / smoother
        const k = this.dragging ? 0.70 : 0.45;
        const diff = this.target - this.offset;
        this.offset += diff * k;

        if (Math.abs(diff) < 0.12) {
          this.offset = this.target;
          this.apply();
          this.raf = null;
          return;
        }
        this.apply();
        this.raf = requestAnimationFrame(tick);
      };
      this.raf = requestAnimationFrame(tick);
    }

    snapToNearestFast(emit=true){
      // Convert translateY back to index:
      // target = CENTER_PX - index*ITEM_H => index = (CENTER_PX - target)/ITEM_H
      const idx = Math.round((this.CENTER_PX - this.target) / ITEM_H);
      const i = clamp(idx, 0, this.values.length - 1);
      const end = this.CENTER_PX - (i * ITEM_H);
      const start = this.offset;

      const dur = 80; // ms (fast snap)
      const t0 = performance.now();
      const easeOut = (t)=> 1 - Math.pow(1 - t, 3);

      if (this.snapRaf) cancelAnimationFrame(this.snapRaf);

      const step = (now) => {
        const t = clamp((now - t0) / dur, 0, 1);
        const e = easeOut(t);
        this.offset = start + (end - start) * e;
        this.target = this.offset;
        this.apply();

        if (t < 1) {
          this.snapRaf = requestAnimationFrame(step);
        } else {
          this.snapRaf = null;
          this.setIndex(i, emit); // lock exact + update box text
        }
      };
      this.snapRaf = requestAnimationFrame(step);
    }

    step(delta){
      this.setIndex(this.index + delta, true);
    }

    bind(){
      // min/max translateY bounds
      const minT = this.CENTER_PX - ((this.values.length - 1) * ITEM_H);
      const maxT = this.CENTER_PX;

      const down = (e) => {
        this.dragging = true;
        this.wrap.setPointerCapture?.(e.pointerId);
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        this.startY = y;
        this.startTarget = this.target;
        this.startFollow();
      };

      const move = (e) => {
        if (!this.dragging) return;
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        const dy = y - this.startY;

        let next = this.startTarget + dy;
        next = clamp(next, minT, maxT);
        this.target = next;
        this.startFollow();
      };

      const up = () => {
        if (!this.dragging) return;
        this.dragging = false;
        this.snapToNearestFast(true);
      };

      this.wrap.addEventListener("pointerdown", down);
      this.wrap.addEventListener("pointermove", move);
      this.wrap.addEventListener("pointerup", up);
      this.wrap.addEventListener("pointercancel", up);

      // fallback
      this.wrap.addEventListener("touchstart", down, { passive:true });
      this.wrap.addEventListener("touchmove", move, { passive:true });
      this.wrap.addEventListener("touchend", up, { passive:true });
    }
  }

  let syncing = false;

  const waterWheel = new DragWheel({
    wrap: document.getElementById("waterWrap"),
    track: document.getElementById("waterTrack"),
    values: waterValues,
    setSelectedText: (w) => { waterSelected.textContent = String(Math.round(w)); },
    onChange: (w) => {
      if (syncing) return;
      syncing = true;
      const c = coffeeFromWater(w);
      const idxC = coffeeValues.indexOf(c);
      coffeeWheel.setIndex(idxC >= 0 ? idxC : 0, true);
      syncing = false;
    }
  });

  const coffeeWheel = new DragWheel({
    wrap: document.getElementById("coffeeWrap"),
    track: document.getElementById("coffeeTrack"),
    values: coffeeValues,
    setSelectedText: (c) => { coffeeSelected.textContent = fmt1(c); },
    onChange: (c) => {
      if (syncing) return;
      syncing = true;
      const w = waterFromCoffee(c);
      const idxW = waterValues.indexOf(w);
      waterWheel.setIndex(idxW >= 0 ? idxW : 0, true);
      syncing = false;
    }
  });

  // Buttons
  document.getElementById("waterDown").onclick  = () => waterWheel.step(-1);
  document.getElementById("waterUp").onclick    = () => waterWheel.step(+1);
  document.getElementById("coffeeDown").onclick = () => coffeeWheel.step(-1);
  document.getElementById("coffeeUp").onclick   = () => coffeeWheel.step(+1);

  // Init at 1000 ml => 64.0 g
  const startW = clamp(waterCfg.start, waterCfg.min, waterCfg.max);
  const startC = coffeeFromWater(startW);

  const idxW = waterValues.indexOf(startW);
  const idxC = coffeeValues.indexOf(startC);

  syncing = true;
  waterWheel.setIndex(idxW >= 0 ? idxW : 0, false);
  coffeeWheel.setIndex(idxC >= 0 ? idxC : 0, false);
  syncing = false;

  // Force sync once
  waterWheel.onChange?.(waterValues[waterWheel.index], waterWheel.index);
})();
</script>
</body>
</html>
