<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Coffee Wheels</title>
  <style>
    :root{
      --bg:#050505;
      --fg:#fff;
      --line:rgba(255,255,255,.22);
      --card:rgba(255,255,255,.03);

      --radius:22px;
      --itemH:56px;
      --visible:5; /* odd */
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{ width:min(780px, 100%); }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }

    .panel{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--card);
      padding: 14px;
    }

    .title{
      text-align:center;
      font-weight:700;
      font-size:16px;
      color:rgba(255,255,255,.95);
      margin: 4px 0 12px;
      letter-spacing: .2px;
    }

    .wheelWrap{
      position:relative;
      height: calc(var(--itemH) * var(--visible));
      border-radius: 18px;
      overflow:hidden;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      touch-action: none; /* we handle dragging */
      user-select:none;
    }

    /* Center selection highlight */
    .wheelWrap::before{
      content:"";
      position:absolute;
      left:12px; right:12px;
      top: calc((var(--visible) / 2) * var(--itemH) - (var(--itemH) / 2));
      height: var(--itemH);
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      z-index: 3;
      pointer-events:none;
    }

    /* Fade top/bottom */
    .wheelWrap::after{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(to bottom,
        rgba(5,5,5,0.98) 0%,
        rgba(5,5,5,0.00) 26%,
        rgba(5,5,5,0.00) 74%,
        rgba(5,5,5,0.98) 100%);
      z-index:2;
      pointer-events:none;
    }

    .track{
      position:absolute;
      inset:0;
      z-index:1;
      will-change: transform;
      /* smoother visual motion */
      transition: transform 0ms;
    }

    /* IMPORTANT: we add top padding INSIDE the list so the selected row can sit in the center */
    .items{
      width:100%;
      padding-top: calc((var(--visible) / 2) * var(--itemH));
      padding-bottom: calc((var(--visible) / 2) * var(--itemH));
      padding-left: 10px;
      padding-right: 10px;
    }

    .item{
      height: var(--itemH);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 40px;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      color: var(--fg);
      opacity: .92;
    }

    .controls{
      display:flex;
      gap:10px;
      margin-top:12px;
    }

    .btn{
      flex:1;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--fg);
      border-radius: 16px;
      padding: 12px 10px;
      font-size: 18px;
      font-weight: 700;
      line-height: 1;
    }
    .btn:active{ transform: scale(0.99); }

    @media (max-width: 520px){
      .grid{ grid-template-columns: 1fr; }
      .item{ font-size: 42px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="grid">
      <div class="panel">
        <div class="title">Coffee (g)</div>
        <div class="wheelWrap" id="coffeeWrap" aria-label="Coffee wheel">
          <div class="track" id="coffeeTrack">
            <div class="items" id="coffeeItems"></div>
          </div>
        </div>
        <div class="controls">
          <button class="btn" id="coffeeDown" type="button">▼</button>
          <button class="btn" id="coffeeUp" type="button">▲</button>
        </div>
      </div>

      <div class="panel">
        <div class="title">Water (ml)</div>
        <div class="wheelWrap" id="waterWrap" aria-label="Water wheel">
          <div class="track" id="waterTrack">
            <div class="items" id="waterItems"></div>
          </div>
        </div>
        <div class="controls">
          <button class="btn" id="waterDown" type="button">▼</button>
          <button class="btn" id="waterUp" type="button">▲</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Locked ratio: 16 / 250
  const R_C = 16;
  const R_W = 250;

  const ITEM_H = 56;   // must match CSS --itemH
  const VISIBLE = 5;   // must match CSS --visible
  const CENTER_PAD = (VISIBLE / 2) * ITEM_H; // 2.5 * 56 => 140, but we use padding in CSS (2 * 56) effectively
  // We'll compute center padding precisely using integer rows:
  const CENTER_ROWS = Math.floor(VISIBLE / 2); // 2 for visible=5
  const CENTER_PX = CENTER_ROWS * ITEM_H;      // 112

  const waterCfg = { min:150, max:1000, step:5, start:1000 };
  const coffeeStep = 0.1;

  const clamp = (x,a,b)=> Math.min(b, Math.max(a, x));
  const roundTo = (x, step)=> Math.round(x/step)*step;
  const fmt1 = (x)=> (Math.round(x*10)/10).toFixed(1);

  function buildValues(min, max, step){
    const out = [];
    const n = Math.round((max - min) / step);
    for(let i=0;i<=n;i++) out.push(min + i*step);
    if (Math.abs(out[out.length-1] - max) > step/2) out.push(max);
    return out;
  }

  const waterValues = buildValues(waterCfg.min, waterCfg.max, waterCfg.step);

  const coffeeMin = roundTo((waterCfg.min * R_C) / R_W, coffeeStep);
  const coffeeMax = roundTo((waterCfg.max * R_C) / R_W, coffeeStep);
  const coffeeValues = buildValues(coffeeMin, coffeeMax, coffeeStep);

  const coffeeFromWater = (w)=> roundTo((w * R_C) / R_W, coffeeStep);
  const waterFromCoffee = (c)=> roundTo((c * R_W) / R_C, waterCfg.step);

  function renderItems(container, values, formatter){
    container.innerHTML = "";
    for(const v of values){
      const div = document.createElement("div");
      div.className = "item";
      div.textContent = formatter(v);
      container.appendChild(div);
    }
  }

  renderItems(document.getElementById("waterItems"), waterValues, v => String(Math.round(v)));
  renderItems(document.getElementById("coffeeItems"), coffeeValues, v => fmt1(v));

  class DragWheel {
    constructor({ wrap, track, values, onChange }) {
      this.wrap = wrap;
      this.track = track;
      this.values = values;
      this.onChange = onChange;

      this.index = 0;

      // offsetY is translation applied to track
      // With padding-top inside items, CENTER is at translateY = -(index*ITEM_H)
      this.offsetY = 0;

      // fluid drag uses a "soft follow" (low-pass filter)
      this.dragging = false;
      this.startY = 0;
      this.startOffset = 0;

      this.targetOffset = 0;
      this.raf = null;

      this.bind();
      this.snapToIndex(0, false);
    }

    applyTransform(){
      this.track.style.transform = `translateY(${this.offsetY}px)`;
    }

    setIndex(idx, emit=true){
      const clamped = clamp(idx, 0, this.values.length - 1);
      this.index = clamped;
      this.offsetY = -(clamped * ITEM_H);
      this.targetOffset = this.offsetY;
      this.applyTransform();
      if (emit) this.onChange?.(this.values[this.index], this.index);
    }

    snapToNearest(emit=true){
      const idx = Math.round(-this.offsetY / ITEM_H);
      this.setIndex(idx, emit);
    }

    snapToIndex(idx, emit=true){
      this.setIndex(idx, emit);
    }

    step(delta){
      this.setIndex(this.index + delta, true);
    }

    // Smooth following while dragging (but still deterministic)
    startRAF(){
      if (this.raf) return;
      const tick = () => {
        // critically damped-ish: move 35% toward target each frame
        const diff = this.targetOffset - this.offsetY;
        this.offsetY += diff * 0.35;
        if (Math.abs(diff) < 0.2) {
          this.offsetY = this.targetOffset;
          this.applyTransform();
          this.raf = null;
          return;
        }
        this.applyTransform();
        this.raf = requestAnimationFrame(tick);
      };
      this.raf = requestAnimationFrame(tick);
    }

    bind(){
      const down = (e) => {
        this.dragging = true;
        this.wrap.setPointerCapture?.(e.pointerId);
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        this.startY = y;
        this.startOffset = this.targetOffset; // use target for continuity
      };

      const move = (e) => {
        if (!this.dragging) return;
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        const dy = y - this.startY;

        // direct mapping, clamped. No inertia.
        let nextTarget = this.startOffset + dy;

        const minOffset = -((this.values.length - 1) * ITEM_H);
        const maxOffset = 0;
        nextTarget = clamp(nextTarget, minOffset, maxOffset);

        this.targetOffset = nextTarget;
        this.startRAF(); // makes it feel fluid
      };

      const up = () => {
        if (!this.dragging) return;
        this.dragging = false;

        // lock instantly to the exact center row
        const idx = Math.round(-this.targetOffset / ITEM_H);
        this.setIndex(idx, true);
      };

      this.wrap.addEventListener("pointerdown", down);
      this.wrap.addEventListener("pointermove", move);
      this.wrap.addEventListener("pointerup", up);
      this.wrap.addEventListener("pointercancel", up);

      // fallback
      this.wrap.addEventListener("touchstart", down, { passive:true });
      this.wrap.addEventListener("touchmove", move, { passive:true });
      this.wrap.addEventListener("touchend", up, { passive:true });
    }
  }

  let updating = false;

  const waterWheel = new DragWheel({
    wrap: document.getElementById("waterWrap"),
    track: document.getElementById("waterTrack"),
    values: waterValues,
    onChange: (w) => {
      if (updating) return;
      updating = true;
      const c = coffeeFromWater(w);
      const idxC = coffeeValues.indexOf(c);
      coffeeWheel.snapToIndex(idxC >= 0 ? idxC : 0, true);
      updating = false;
    }
  });

  const coffeeWheel = new DragWheel({
    wrap: document.getElementById("coffeeWrap"),
    track: document.getElementById("coffeeTrack"),
    values: coffeeValues,
    onChange: (c) => {
      if (updating) return;
      updating = true;
      const w = waterFromCoffee(c);
      const idxW = waterValues.indexOf(w);
      waterWheel.snapToIndex(idxW >= 0 ? idxW : 0, true);
      updating = false;
    }
  });

  // Buttons
  document.getElementById("waterDown").onclick = () => waterWheel.step(-1);
  document.getElementById("waterUp").onclick   = () => waterWheel.step(+1);
  document.getElementById("coffeeDown").onclick = () => coffeeWheel.step(-1);
  document.getElementById("coffeeUp").onclick   = () => coffeeWheel.step(+1);

  // Init: 1000ml => 64.0g
  const startW = clamp(waterCfg.start, waterCfg.min, waterCfg.max);
  const startC = coffeeFromWater(startW);

  const idxW = waterValues.indexOf(startW);
  const idxC = coffeeValues.indexOf(startC);

  updating = true;
  waterWheel.snapToIndex(idxW >= 0 ? idxW : 0, false);
  coffeeWheel.snapToIndex(idxC >= 0 ? idxC : 0, false);
  updating = false;

  // ensure sync
  waterWheel.onChange?.(waterValues[waterWheel.index], waterWheel.index);
})();
</script>
</body>
</html>
