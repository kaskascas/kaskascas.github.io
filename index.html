<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>16-bit Coffee Wheels</title>
  <style>
    :root{
      --bg:#030303;
      --fg:#F8F8F8;

      --ui1:#0A0A0A;
      --ui2:#101010;
      --line:#F8F8F8;
      --line2:rgba(248,248,248,.45);
      --glow:rgba(248,248,248,.25);

      --radius:0px;             /* pixel style */
      --itemH:56px;
      --visible:5;              /* odd */
      --padX:14px;
      --boxInset:10px;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }

    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      -webkit-tap-highlight-color: transparent;
      image-rendering: pixelated;
    }

    /* subtle scanlines */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.03) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0.00) 3px,
        rgba(0,0,0,0.00) 6px
      );
      mix-blend-mode: overlay;
      opacity:.25;
    }

    .wrap{ width:min(820px, 100%); }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }

    /* 16-bit panel */
    .panel{
      background:
        linear-gradient(180deg, var(--ui2), var(--ui1));
      padding: 14px;
      position:relative;

      /* pixel border */
      box-shadow:
        0 0 0 2px var(--line),
        0 0 0 4px rgba(255,255,255,.10),
        0 10px 24px rgba(0,0,0,.55);
    }

    .title{
      text-align:center;
      font-weight: 900;
      font-size: 14px;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin: 2px 0 12px;
      text-shadow: 0 2px 0 rgba(0,0,0,.65);
    }

    .wheelWrap{
      position:relative;
      height: calc(var(--itemH) * var(--visible));
      overflow:hidden;
      background: #050505;

      /* inner pixel border */
      box-shadow:
        inset 0 0 0 2px var(--line),
        inset 0 0 0 4px rgba(255,255,255,.08);
      touch-action: none; /* we handle dragging */
      user-select:none;
    }

    /* THE selection "box" (middle) */
    .wheelWrap::before{
      content:"";
      position:absolute;
      left: var(--boxInset);
      right: var(--boxInset);
      top: calc((var(--visible) / 2) * var(--itemH) - (var(--itemH) / 2));
      height: var(--itemH);

      /* pixel box */
      box-shadow:
        inset 0 0 0 2px var(--line),
        inset 0 0 0 4px rgba(0,0,0,.55),
        0 0 18px var(--glow);
      background: rgba(255,255,255,.06);
      z-index: 3;
      pointer-events:none;
    }

    /* top/bottom fade to emphasize center */
    .wheelWrap::after{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(to bottom,
        rgba(3,3,3,0.98) 0%,
        rgba(3,3,3,0.00) 28%,
        rgba(3,3,3,0.00) 72%,
        rgba(3,3,3,0.98) 100%);
      z-index:2;
      pointer-events:none;
    }

    .track{
      position:absolute;
      inset:0;
      z-index:1;
      will-change: transform;
      transform: translateY(0px);
    }

    /* padding so the selected row sits inside the selection box */
    .items{
      width:100%;
      padding-top: calc((var(--visible) / 2) * var(--itemH));
      padding-bottom: calc((var(--visible) / 2) * var(--itemH));
      padding-left: var(--padX);
      padding-right: var(--padX);
    }

    .item{
      height: var(--itemH);
      display:flex;
      align-items:center;
      justify-content:center;

      font-size: 38px;
      font-weight: 900;
      letter-spacing: 0.5px;
      font-variant-numeric: tabular-nums;
      text-shadow:
        0 2px 0 rgba(0,0,0,.75),
        0 0 10px rgba(255,255,255,.08);
      opacity: .68;
    }

    /* Make the center row look "selected" by letting it naturally sit under the box:
       we don't need per-row detection; the box itself creates the effect. */

    .controls{
      display:flex;
      gap:10px;
      margin-top:12px;
    }

    .btn{
      flex:1;
      border:0;
      background: #060606;
      color: var(--fg);
      font-family: inherit;
      font-weight: 900;
      letter-spacing: 1px;
      padding: 12px 10px;
      font-size: 18px;

      box-shadow:
        0 0 0 2px var(--line),
        inset 0 0 0 2px rgba(0,0,0,.55),
        0 8px 0 rgba(0,0,0,.55);
    }
    .btn:active{
      transform: translateY(6px);
      box-shadow:
        0 0 0 2px var(--line),
        inset 0 0 0 2px rgba(0,0,0,.55),
        0 2px 0 rgba(0,0,0,.55);
    }

    @media (max-width: 520px){
      .grid{ grid-template-columns: 1fr; }
      .item{ font-size: 40px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="grid">
      <div class="panel">
        <div class="title">Coffee (g)</div>
        <div class="wheelWrap" id="coffeeWrap" aria-label="Coffee wheel">
          <div class="track" id="coffeeTrack">
            <div class="items" id="coffeeItems"></div>
          </div>
        </div>
        <div class="controls">
          <button class="btn" id="coffeeDown" type="button">▼</button>
          <button class="btn" id="coffeeUp" type="button">▲</button>
        </div>
      </div>

      <div class="panel">
        <div class="title">Water (ml)</div>
        <div class="wheelWrap" id="waterWrap" aria-label="Water wheel">
          <div class="track" id="waterTrack">
            <div class="items" id="waterItems"></div>
          </div>
        </div>
        <div class="controls">
          <button class="btn" id="waterDown" type="button">▼</button>
          <button class="btn" id="waterUp" type="button">▲</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // LOCKED ratio: 16 / 250
  const R_C = 16, R_W = 250;

  const ITEM_H = 56;   // must match CSS --itemH
  const VISIBLE = 5;   // must match CSS --visible

  // Requested accuracy
  const waterCfg = { min:150, max:1000, step:5, start:1000 };
  const coffeeStep = 0.1;

  const clamp = (x,a,b)=> Math.min(b, Math.max(a,x));
  const roundTo = (x, step)=> Math.round(x/step)*step;
  const fmt1 = (x)=> (Math.round(x*10)/10).toFixed(1);

  function buildValues(min, max, step){
    const out = [];
    const n = Math.round((max - min) / step);
    for(let i=0;i<=n;i++) out.push(min + i*step);
    if (Math.abs(out[out.length-1] - max) > step/2) out.push(max);
    return out;
  }

  const waterValues = buildValues(waterCfg.min, waterCfg.max, waterCfg.step);

  // Derived coffee range from water range under locked ratio
  const coffeeMin = roundTo((waterCfg.min * R_C) / R_W, coffeeStep);
  const coffeeMax = roundTo((waterCfg.max * R_C) / R_W, coffeeStep);
  const coffeeValues = buildValues(coffeeMin, coffeeMax, coffeeStep);

  const coffeeFromWater = (w)=> roundTo((w * R_C) / R_W, coffeeStep);
  const waterFromCoffee = (c)=> roundTo((c * R_W) / R_C, waterCfg.step);

  function renderItems(container, values, formatter){
    container.innerHTML = "";
    for(const v of values){
      const div = document.createElement("div");
      div.className = "item";
      div.textContent = formatter(v);
      container.appendChild(div);
    }
  }

  renderItems(document.getElementById("waterItems"),  waterValues,  v => String(Math.round(v)));
  renderItems(document.getElementById("coffeeItems"), coffeeValues, v => fmt1(v));

  // Fast + smooth: spring follow while dragging, very quick snap on release.
  class DragWheel {
    constructor({ wrap, track, values, onChange }) {
      this.wrap = wrap;
      this.track = track;
      this.values = values;
      this.onChange = onChange;

      this.index = 0;

      // offset is translateY
      this.offset = 0;
      this.target = 0;

      // drag state
      this.dragging = false;
      this.startY = 0;
      this.startTarget = 0;

      // animation
      this.raf = null;
      this.snapRaf = null;

      this.apply();
      this.bind();
    }

    apply(){
      this.track.style.transform = `translateY(${this.offset}px)`;
    }

    setIndex(idx, emit=true){
      const i = clamp(idx, 0, this.values.length - 1);
      this.index = i;
      this.offset = -(i * ITEM_H);
      this.target = this.offset;
      this.apply();
      if (emit) this.onChange?.(this.values[this.index], this.index);
    }

    // Smooth follow: faster + smoother
    startFollow(){
      if (this.raf) return;
      const tick = () => {
        // Higher factor = faster response (fluid & snappy)
        const k = this.dragging ? 0.55 : 0.35;
        const diff = this.target - this.offset;
        this.offset += diff * k;

        if (Math.abs(diff) < 0.15) {
          this.offset = this.target;
          this.apply();
          this.raf = null;
          return;
        }
        this.apply();
        this.raf = requestAnimationFrame(tick);
      };
      this.raf = requestAnimationFrame(tick);
    }

    // Quick snap (no floaty movement after release)
    snapToNearestFast(emit=true){
      const idx = Math.round(-this.target / ITEM_H);
      const i = clamp(idx, 0, this.values.length - 1);
      const snapTarget = -(i * ITEM_H);

      // Tiny, fast ease-out (looks smooth, ends immediately)
      const start = this.offset;
      const end = snapTarget;
      const dur = 90; // ms
      const t0 = performance.now();

      if (this.snapRaf) cancelAnimationFrame(this.snapRaf);

      const easeOut = (t)=> 1 - Math.pow(1 - t, 3);

      const step = (now) => {
        const t = clamp((now - t0) / dur, 0, 1);
        const e = easeOut(t);
        this.offset = start + (end - start) * e;
        this.target = this.offset;
        this.apply();

        if (t < 1) {
          this.snapRaf = requestAnimationFrame(step);
        } else {
          this.snapRaf = null;
          this.setIndex(i, emit); // lock exact
        }
      };
      this.snapRaf = requestAnimationFrame(step);
    }

    step(delta){
      this.setIndex(this.index + delta, true);
    }

    bind(){
      const minOffset = -((this.values.length - 1) * ITEM_H);
      const maxOffset = 0;

      const down = (e) => {
        this.dragging = true;
        this.wrap.setPointerCapture?.(e.pointerId);
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        this.startY = y;
        this.startTarget = this.target;
        this.startFollow();
      };

      const move = (e) => {
        if (!this.dragging) return;
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        const dy = y - this.startY;

        // Faster feel: 1:1 drag, clamped
        let next = this.startTarget + dy;
        next = clamp(next, minOffset, maxOffset);
        this.target = next;
        this.startFollow();
      };

      const up = () => {
        if (!this.dragging) return;
        this.dragging = false;
        this.snapToNearestFast(true);
      };

      this.wrap.addEventListener("pointerdown", down);
      this.wrap.addEventListener("pointermove", move);
      this.wrap.addEventListener("pointerup", up);
      this.wrap.addEventListener("pointercancel", up);

      // fallback
      this.wrap.addEventListener("touchstart", down, { passive:true });
      this.wrap.addEventListener("touchmove", move, { passive:true });
      this.wrap.addEventListener("touchend", up, { passive:true });
    }
  }

  let syncing = false;

  const waterWheel = new DragWheel({
    wrap: document.getElementById("waterWrap"),
    track: document.getElementById("waterTrack"),
    values: waterValues,
    onChange: (w) => {
      if (syncing) return;
      syncing = true;
      const c = coffeeFromWater(w);
      const idxC = coffeeValues.indexOf(c);
      coffeeWheel.setIndex(idxC >= 0 ? idxC : 0, true);
      syncing = false;
    }
  });

  const coffeeWheel = new DragWheel({
    wrap: document.getElementById("coffeeWrap"),
    track: document.getElementById("coffeeTrack"),
    values: coffeeValues,
    onChange: (c) => {
      if (syncing) return;
      syncing = true;
      const w = waterFromCoffee(c);
      const idxW = waterValues.indexOf(w);
      waterWheel.setIndex(idxW >= 0 ? idxW : 0, true);
      syncing = false;
    }
  });

  // Buttons
  document.getElementById("waterDown").onclick  = () => waterWheel.step(-1);
  document.getElementById("waterUp").onclick    = () => waterWheel.step(+1);
  document.getElementById("coffeeDown").onclick = () => coffeeWheel.step(-1);
  document.getElementById("coffeeUp").onclick   = () => coffeeWheel.step(+1);

  // Init at 1000 ml => 64.0 g
  const startW = clamp(waterCfg.start, waterCfg.min, waterCfg.max);
  const startC = coffeeFromWater(startW);

  const idxW = waterValues.indexOf(startW);
  const idxC = coffeeValues.indexOf(startC);

  syncing = true;
  waterWheel.setIndex(idxW >= 0 ? idxW : 0, false);
  coffeeWheel.setIndex(idxC >= 0 ? idxC : 0, false);
  syncing = false;

  // Force sync once
  waterWheel.onChange?.(waterValues[waterWheel.index], waterWheel.index);
})();
</script>
</body>
</html>
