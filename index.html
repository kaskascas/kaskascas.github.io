<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Coffee Wheels</title>
  <style>
    :root{
      --bg:#070707;                 /* much darker */
      --fg:#FFFFFF;
      --line:rgba(255,255,255,.22);
      --card:rgba(255,255,255,.03);

      --radius:22px;
      --visible:5;                  /* odd */
      --itemH:56px;                 /* visual target; JS measures real height */
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{ width:min(760px, 100%); }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    .panel{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--card);
      padding: 14px;
    }

    .title{
      text-align:center;
      font-weight: 650;
      font-size: 16px;
      margin: 4px 0 12px;
      color: rgba(255,255,255,.92);
    }

    .wheelWrap{
      position:relative;
      height: calc(var(--itemH) * var(--visible));
      border-radius: 18px;
      overflow:hidden;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      touch-action: pan-y;
    }

    /* Center selection highlight */
    .wheelWrap::before{
      content:"";
      position:absolute;
      left:12px; right:12px;
      top: calc((var(--visible) / 2) * var(--itemH) - (var(--itemH) / 2));
      height: var(--itemH);
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      z-index: 3;
      pointer-events:none;
    }

    /* Fade top/bottom */
    .wheelWrap::after{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(to bottom,
        rgba(7,7,7,0.98) 0%,
        rgba(7,7,7,0.00) 26%,
        rgba(7,7,7,0.00) 74%,
        rgba(7,7,7,0.98) 100%);
      z-index:2;
      pointer-events:none;
    }

    .wheel{
      height:100%;
      overflow-y:auto;

      /* strong snapping */
      scroll-snap-type: y mandatory;
      scroll-snap-stop: always;

      /* IMPORTANT: kill momentum so it stops on release */
      -webkit-overflow-scrolling: auto;

      padding: calc((var(--visible) / 2) * var(--itemH)) 10px;
      scrollbar-width:none;
    }
    .wheel::-webkit-scrollbar{ display:none; }

    .item{
      height: var(--itemH);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 38px;
      font-weight: 700;
      color: var(--fg);
      font-variant-numeric: tabular-nums;
      scroll-snap-align: center;
      user-select:none;
    }

    @media (max-width: 520px){
      .grid{ grid-template-columns: 1fr; }
      .item{ font-size: 40px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="grid">
      <div class="panel">
        <div class="title">Coffee (g)</div>
        <div class="wheelWrap">
          <div id="coffeeWheel" class="wheel" aria-label="Coffee wheel"></div>
        </div>
      </div>

      <div class="panel">
        <div class="title">Water (ml)</div>
        <div class="wheelWrap">
          <div id="waterWheel" class="wheel" aria-label="Water wheel"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // LOCKED ratio: 16 / 250
  const R_C = 16;
  const R_W = 250;

  const cfg = {
    water: { min: 150, max: 1000, step: 1, start: 250 }, // 150–1000 ml
    coffeeStep: 0.1                                       // 0.1 g
  };

  const coffeeWheel = document.getElementById("coffeeWheel");
  const waterWheel  = document.getElementById("waterWheel");

  const clamp = (x,a,b)=> Math.min(b, Math.max(a,x));
  const roundTo = (x, step)=> Math.round(x/step)*step;
  const fmt1 = (x)=> (Math.round(x*10)/10).toFixed(1);

  function buildValues(min, max, step){
    const out = [];
    const nSteps = Math.round((max - min) / step);
    for(let i=0;i<=nSteps;i++) out.push(min + i*step);
    if (Math.abs(out[out.length-1] - max) > step/2) out.push(max);
    return out;
  }

  const waterValues = buildValues(cfg.water.min, cfg.water.max, cfg.water.step);

  // derived coffee range from locked ratio
  const coffeeMin = roundTo((cfg.water.min * R_C) / R_W, cfg.coffeeStep);
  const coffeeMax = roundTo((cfg.water.max * R_C) / R_W, cfg.coffeeStep);
  const coffeeValues = buildValues(coffeeMin, coffeeMax, cfg.coffeeStep);

  function populateWheel(wheelEl, values, formatter){
    wheelEl.innerHTML = "";
    for (const v of values){
      const div = document.createElement("div");
      div.className = "item";
      div.dataset.value = String(v);
      div.textContent = formatter(v);
      wheelEl.appendChild(div);
    }
  }

  populateWheel(waterWheel, waterValues, (v)=> String(Math.round(v)));
  populateWheel(coffeeWheel, coffeeValues, (v)=> fmt1(v));

  // Measure real row height for perfect lock (font/device differences)
  function itemH(wheelEl){
    const first = wheelEl.querySelector(".item");
    return first ? first.getBoundingClientRect().height : 56;
  }

  function nearestIndex(wheelEl, values){
    const h = itemH(wheelEl);
    const idx = Math.round(wheelEl.scrollTop / h);
    return clamp(idx, 0, values.length - 1);
  }

  // INSTANT snap (no animation, no bounce)
  function snapIndexInstant(wheelEl, idx){
    const h = itemH(wheelEl);
    const top = idx * h;
    wheelEl.scrollTo({ top, behavior: "auto" }); // immediate
  }

  function scrollToValueInstant(wheelEl, values, value){
    // find nearest
    let bestIdx = 0, best = Infinity;
    for(let i=0;i<values.length;i++){
      const d = Math.abs(values[i] - value);
      if(d < best){ best = d; bestIdx = i; }
    }
    snapIndexInstant(wheelEl, bestIdx);
    return bestIdx;
  }

  const coffeeFromWater = (w)=> roundTo((w * R_C) / R_W, cfg.coffeeStep);
  const waterFromCoffee = (c)=> roundTo((c * R_W) / R_C, cfg.water.step);

  let active = "water";

  function settleWaterInstant(){
    const idxW = nearestIndex(waterWheel, waterValues);
    snapIndexInstant(waterWheel, idxW);
    const w = waterValues[idxW];
    const c = coffeeFromWater(w);
    scrollToValueInstant(coffeeWheel, coffeeValues, c);
  }

  function settleCoffeeInstant(){
    const idxC = nearestIndex(coffeeWheel, coffeeValues);
    snapIndexInstant(coffeeWheel, idxC);
    const c = coffeeValues[idxC];
    const w = waterFromCoffee(c);
    scrollToValueInstant(waterWheel, waterValues, w);
  }

  // Settle on finger release = “no movement after chosen”
  function bindRelease(wheelEl, which){
    const settle = () => (which === "water") ? settleWaterInstant() : settleCoffeeInstant();
    wheelEl.addEventListener("touchend", settle, { passive:true });
    wheelEl.addEventListener("pointerup", settle, { passive:true });
    wheelEl.addEventListener("mouseup", settle, { passive:true });

    // Also: if user flings and scroll keeps going, this catches final stop quickly
    let t = null;
    wheelEl.addEventListener("scroll", () => {
      active = which;
      if (t) clearTimeout(t);
      t = setTimeout(() => {
        if (active === which) settle();
      }, 70);
    }, { passive:true });
  }

  bindRelease(waterWheel, "water");
  bindRelease(coffeeWheel, "coffee");

  // init
  function init(){
    const startW = clamp(cfg.water.start, cfg.water.min, cfg.water.max);
    const startC = coffeeFromWater(startW);

    // after layout, snap exactly
    requestAnimationFrame(() => {
      scrollToValueInstant(waterWheel, waterValues, startW);
      scrollToValueInstant(coffeeWheel, coffeeValues, startC);
    });
  }

  init();
})();
</script>
</body>
</html>
