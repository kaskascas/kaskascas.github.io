<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Coffee Wheels</title>
  <style>
    :root{
      --bg:#0B0B0B;                 /* darker */
      --fg:#FFFFFF;
      --line:rgba(255,255,255,.20);
      --line2:rgba(255,255,255,.12);
      --card:rgba(255,255,255,.03);

      --radius:22px;
      --visible:5;                  /* must be odd */
      --itemH:52px;                 /* visual target; JS measures real height */
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-rounded, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{ width:min(760px, 100%); }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    .panel{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--card);
      padding: 14px;
    }

    .title{
      text-align:center;
      font-weight: 650;
      font-size: 16px;
      letter-spacing: .2px;
      margin: 4px 0 12px;
      color: rgba(255,255,255,.92);
    }

    .wheelWrap{
      position:relative;
      height: calc(var(--itemH) * var(--visible));
      border-radius: 18px;
      overflow:hidden;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      touch-action: pan-y;
    }

    .wheelWrap::before{
      content:"";
      position:absolute;
      left:12px; right:12px;
      top: calc((var(--visible) / 2) * var(--itemH) - (var(--itemH) / 2));
      height: var(--itemH);
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      z-index: 3;
      pointer-events:none;
    }

    .wheelWrap::after{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(to bottom,
        rgba(11,11,11,0.98) 0%,
        rgba(11,11,11,0.00) 26%,
        rgba(11,11,11,0.00) 74%,
        rgba(11,11,11,0.98) 100%);
      z-index:2;
      pointer-events:none;
    }

    .wheel{
      height:100%;
      overflow-y:auto;
      scroll-snap-type: y mandatory;
      scroll-snap-stop: always;
      -webkit-overflow-scrolling: touch;
      padding: calc((var(--visible) / 2) * var(--itemH)) 10px;
      scrollbar-width:none;
    }
    .wheel::-webkit-scrollbar{ display:none; }

    .item{
      height: var(--itemH);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 36px;
      font-weight: 700;
      color: var(--fg);
      font-variant-numeric: tabular-nums;
      scroll-snap-align: center;
      user-select:none;
    }

    @media (max-width: 520px){
      .grid{ grid-template-columns: 1fr; }
      .item{ font-size: 38px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="grid">
      <div class="panel">
        <div class="title">Coffee (g)</div>
        <div class="wheelWrap">
          <div id="coffeeWheel" class="wheel" aria-label="Coffee wheel"></div>
        </div>
      </div>

      <div class="panel">
        <div class="title">Water (ml)</div>
        <div class="wheelWrap">
          <div id="waterWheel" class="wheel" aria-label="Water wheel"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Locked ratio: coffee = water * 16 / 250
  const R_C = 16;
  const R_W = 250;

  const cfg = {
    visible: 5,
    water: { min: 150, max: 1000, step: 1, start: 250 }, // 150–1000 ml
    coffeeStep: 0.1                                     // 0.1g
  };

  const coffeeWheel = document.getElementById("coffeeWheel");
  const waterWheel  = document.getElementById("waterWheel");

  const clamp = (x,a,b)=> Math.min(b, Math.max(a,x));
  const roundTo = (x, step)=> Math.round(x/step)*step;
  const fmt1 = (x)=> (Math.round(x*10)/10).toFixed(1);

  function buildValues(min, max, step){
    const out = [];
    const nSteps = Math.round((max - min) / step);
    for(let i=0;i<=nSteps;i++) out.push(min + i*step);
    if (Math.abs(out[out.length-1] - max) > step/2) out.push(max);
    return out;
  }

  const waterValues = buildValues(cfg.water.min, cfg.water.max, cfg.water.step);

  // coffee range derived from water range under locked ratio
  const coffeeMin = roundTo((cfg.water.min * R_C) / R_W, cfg.coffeeStep);
  const coffeeMax = roundTo((cfg.water.max * R_C) / R_W, cfg.coffeeStep);
  const coffeeValues = buildValues(coffeeMin, coffeeMax, cfg.coffeeStep);

  function populateWheel(wheelEl, values, formatter){
    wheelEl.innerHTML = "";
    for (const v of values){
      const div = document.createElement("div");
      div.className = "item";
      div.dataset.value = String(v);
      div.textContent = formatter(v);
      wheelEl.appendChild(div);
    }
  }

  populateWheel(waterWheel, waterValues, (v)=> String(Math.round(v)));
  populateWheel(coffeeWheel, coffeeValues, (v)=> fmt1(v));

  // Measure REAL item height (fixes “won’t lock” issue on some phones)
  function getItemH(wheelEl){
    const first = wheelEl.querySelector(".item");
    return first ? first.getBoundingClientRect().height : 52;
  }

  function animateScrollTo(wheelEl, targetTop, { duration=160, bounce=true } = {}){
    const startTop = wheelEl.scrollTop;
    const delta = targetTop - startTop;
    if (Math.abs(delta) < 0.5) { wheelEl.scrollTop = targetTop; return; }

    const start = performance.now();
    const easeOutCubic = (t)=> 1 - Math.pow(1 - t, 3);

    const overshoot = bounce ? clamp(delta * 0.06, -14, 14) : 0;
    const overshootTop = targetTop + overshoot;

    function step(now){
      const t = clamp((now - start) / duration, 0, 1);
      const e = easeOutCubic(t);

      if (bounce && t < 0.82){
        wheelEl.scrollTop = startTop + (overshootTop - startTop) * (e / 0.82);
      } else if (bounce){
        const t2 = (t - 0.82) / 0.18;
        const e2 = easeOutCubic(clamp(t2,0,1));
        wheelEl.scrollTop = overshootTop + (targetTop - overshootTop) * e2;
      } else {
        wheelEl.scrollTop = startTop + delta * e;
      }

      if (t < 1) requestAnimationFrame(step);
      else wheelEl.scrollTop = targetTop;
    }
    requestAnimationFrame(step);
  }

  function nearestIndex(wheelEl, values){
    const itemH = getItemH(wheelEl);
    const idx = Math.round(wheelEl.scrollTop / itemH);
    return clamp(idx, 0, values.length - 1);
  }

  function snapIndex(wheelEl, idx, { bounce=true } = {}){
    const itemH = getItemH(wheelEl);
    const top = idx * itemH;
    animateScrollTo(wheelEl, top, { duration: 170, bounce });
  }

  function scrollToValue(wheelEl, values, value, { bounce=true } = {}){
    // nearest value index (dense lists, linear is fine here)
    let bestIdx = 0, best = Infinity;
    for(let i=0;i<values.length;i++){
      const d = Math.abs(values[i] - value);
      if(d < best){ best = d; bestIdx = i; }
    }
    snapIndex(wheelEl, bestIdx, { bounce });
    return bestIdx;
  }

  // ratio conversions
  const coffeeFromWater = (w)=> roundTo((w * R_C) / R_W, cfg.coffeeStep);
  const waterFromCoffee = (c)=> roundTo((c * R_W) / R_C, cfg.water.step);

  let active = "water";
  let settleTimerW = null, settleTimerC = null;
  const SETTLE_MS = 80;

  function settleWater(){
    const idxW = nearestIndex(waterWheel, waterValues);
    snapIndex(waterWheel, idxW, { bounce:true });
    const w = waterValues[idxW];
    const c = coffeeFromWater(w);
    scrollToValue(coffeeWheel, coffeeValues, c, { bounce:true });
  }

  function settleCoffee(){
    const idxC = nearestIndex(coffeeWheel, coffeeValues);
    snapIndex(coffeeWheel, idxC, { bounce:true });
    const c = coffeeValues[idxC];
    const w = waterFromCoffee(c);
    scrollToValue(waterWheel, waterValues, w, { bounce:true });
  }

  // scroll handlers (light debounce)
  waterWheel.addEventListener("scroll", () => {
    active = "water";
    if (settleTimerW) clearTimeout(settleTimerW);
    settleTimerW = setTimeout(() => { if(active==="water") settleWater(); }, SETTLE_MS);
  }, { passive:true });

  coffeeWheel.addEventListener("scroll", () => {
    active = "coffee";
    if (settleTimerC) clearTimeout(settleTimerC);
    settleTimerC = setTimeout(() => { if(active==="coffee") settleCoffee(); }, SETTLE_MS);
  }, { passive:true });

  // IMPORTANT: lock-in on finger release for perfect snapping
  function bindReleaseSnap(wheelEl, which){
    const doSettle = () => (which === "water") ? settleWater() : settleCoffee();
    wheelEl.addEventListener("touchend", doSettle, { passive:true });
    wheelEl.addEventListener("mouseup", doSettle, { passive:true });
    wheelEl.addEventListener("pointerup", doSettle, { passive:true });
  }
  bindReleaseSnap(waterWheel, "water");
  bindReleaseSnap(coffeeWheel, "coffee");

  // init at 250 ml => 16.0 g
  function init(){
    const startW = clamp(cfg.water.start, cfg.water.min, cfg.water.max);
    const startC = coffeeFromWater(startW);

    scrollToValue(waterWheel, waterValues, startW, { bounce:false });
    scrollToValue(coffeeWheel, coffeeValues, startC, { bounce:false });

    // force exact alignment after layout
    requestAnimationFrame(() => {
      const itemHW = getItemH(waterWheel);
      const itemHC = getItemH(coffeeWheel);
      const idxW = waterValues.indexOf(startW);
      const idxC = coffeeValues.indexOf(startC);
      if (idxW >= 0) waterWheel.scrollTop = idxW * itemHW;
      if (idxC >= 0) coffeeWheel.scrollTop = idxC * itemHC;
    });
  }

  init();
})();
</script>
</body>
</html>
